;; Analyzed by ClojureScript 1.7.228
{:use-macros {with-compiler-env cljs.env.macros}, :excludes #{find-ns ns-publics ns-interns load-file}, :name replumb.repl, :imports nil, :requires {cljs cljs.js, load replumb.load, cljs.tools.reader cljs.tools.reader, replumb.load replumb.load, tags cljs.tagged-literals, r cljs.tools.reader, cljs.js cljs.js, cljs.tools.reader.reader-types cljs.tools.reader.reader-types, cljs.env cljs.env, ana cljs.analyzer, browser replumb.browser, docs replumb.doc-maps, cljs.pprint cljs.pprint, cljs.tagged-literals cljs.tagged-literals, ast replumb.ast, nodejs replumb.nodejs, env cljs.env, s clojure.string, replumb.doc-maps replumb.doc-maps, replumb.browser replumb.browser, cljs.analyzer cljs.analyzer, common replumb.common, cljs.repl cljs.repl, replumb.ast replumb.ast, rt cljs.tools.reader.reader-types, clojure.string clojure.string, replumb.nodejs replumb.nodejs, repl cljs.repl, replumb.common replumb.common}, :uses {pprint cljs.pprint}, :defs {auto-init-opts {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 707, :column 7, :end-line 707, :end-column 21, :arglists (quote ([opts])), :doc "Just assoc the options to persist to the input map."}, :name replumb.repl/auto-init-opts, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 21, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 707, :end-line 707, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :doc "Just assoc the options to persist to the input map."}, success-map {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 290, :column 7, :end-line 290, :end-column 18, :arglists (quote ([opts form warning value])), :doc "Builds the map to return when the evaluation returned success.\n  Supports the following options:\n\n  * :no-pr-str-on-value avoids wrapping value in pr-str."}, :name replumb.repl/success-map, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 18, :method-params ([opts form warning value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 290, :end-line 290, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts form warning value])), :doc "Builds the map to return when the evaluation returned success.\n  Supports the following options:\n\n  * :no-pr-str-on-value avoids wrapping value in pr-str."}, valid-opts {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 239, :column 7, :end-line 239, :end-column 17, :arglists (quote ([user-opts])), :doc "Validate the input user options. Returns a new map without invalid\n  ones according to valid-opts-set."}, :name replumb.repl/valid-opts, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 17, :method-params ([user-opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 239, :end-line 239, :max-fixed-arity 1, :fn-var true, :arglists (quote ([user-opts])), :doc "Validate the input user options. Returns a new map without invalid\n  ones according to valid-opts-set."}, needs-init-from-opts-state {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 719, :column 7, :end-line 719, :end-column 33, :arglists (quote ([old-app-env new-opts])), :doc "Update the :previous-auto-init-opts and, if necessary, also\n  turns :needs-init? to true, concretely deciding whether when need to\n  initialise again. Move the state to \"Needs Init\"."}, :name replumb.repl/needs-init-from-opts-state, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 33, :method-params ([old-app-env new-opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 719, :end-line 719, :max-fixed-arity 2, :fn-var true, :arglists (quote ([old-app-env new-opts])), :doc "Update the :previous-auto-init-opts and, if necessary, also\n  turns :needs-init? to true, concretely deciding whether when need to\n  initialise again. Move the state to \"Needs Init\"."}, initialized-state {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 699, :column 7, :end-line 699, :end-column 24, :arglists (quote ([old-app-env])), :doc "Move the state to \"Initialized\", signaling that the init is not in\n  progress and done."}, :name replumb.repl/initialized-state, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 24, :method-params ([old-app-env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 699, :end-line 699, :max-fixed-arity 1, :fn-var true, :arglists (quote ([old-app-env])), :doc "Move the state to \"Initialized\", signaling that the init is not in\n  progress and done."}, fetch-source {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 552, :column 7, :end-line 552, :end-column 19, :arglists (quote ([{:keys [verbose read-file-fn!]} var paths-to-try cb]))}, :name replumb.repl/fetch-source, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 19, :method-params ([p__15001 var paths-to-try cb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 552, :end-line 552, :max-fixed-arity 4, :fn-var true, :arglists (quote ([{:keys [verbose read-file-fn!]} var paths-to-try cb]))}, process-apropos {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 598, :column 7, :end-line 598, :end-column 22, :arglists (quote ([opts cb data str-or-pattern]))}, :name replumb.repl/process-apropos, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 22, :method-params ([opts cb data str-or-pattern]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 598, :end-line 598, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data str-or-pattern]))}, make-load-fn {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 202, :column 7, :end-line 202, :end-column 19, :arglists (quote ([verbose? src-paths read-file-fn!])), :doc "Makes a load function that will read from a sequence of src-paths\n  using a supplied read-file-fn!. It returns a cljs.js-compatible\n  *load-fn*.\n\n  Read-file-fn! is an async 2-arity function with signature [file-path\n  src-cb] where src-cb is itself a function (fn [source] ...) that needs\n  to be called with the full source of the library (as string)."}, :name replumb.repl/make-load-fn, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 19, :method-params ([verbose? src-paths read-file-fn!]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 202, :end-line 202, :max-fixed-arity 3, :fn-var true, :arglists (quote ([verbose? src-paths read-file-fn!])), :doc "Makes a load function that will read from a sequence of src-paths\n  using a supplied read-file-fn!. It returns a cljs.js-compatible\n  *load-fn*.\n\n  Read-file-fn! is an async 2-arity function with signature [file-path\n  src-cb] where src-cb is itself a function (fn [source] ...) that needs\n  to be called with the full source of the library (as string)."}, reset-env! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 876, :column 7, :end-line 876, :end-column 17, :arglists (quote ([] [opts] [opts namespaces])), :doc "It does the following (in order):\n\n  1. in-ns to cljs.user\n  2. remove the input namespaces from the compiler environment\n  3. reset the last warning\n  4. set *e to nil\n\n  It accepts a sequence of symbols or strings.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [opts] [opts namespaces]), :arglists ([] [opts] [opts namespaces]), :arglists-meta (nil nil nil)}}, :name replumb.repl/reset-env!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([] [opts] [opts namespaces]), :arglists ([] [opts] [opts namespaces]), :arglists-meta (nil nil nil)}, :method-params ([] [opts] [opts namespaces]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 876, :end-line 876, :max-fixed-arity 2, :fn-var true, :arglists ([] [opts] [opts namespaces]), :doc "It does the following (in order):\n\n  1. in-ns to cljs.user\n  2. remove the input namespaces from the compiler environment\n  3. reset the last warning\n  4. set *e to nil\n\n  It accepts a sequence of symbols or strings."}, validated-call-back! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 328, :column 7, :end-line 328, :end-column 27, :arglists (quote ([opts cb res]))}, :name replumb.repl/validated-call-back!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 27, :method-params ([opts cb res]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 328, :end-line 328, :max-fixed-arity 3, :fn-var true, :arglists (quote ([opts cb res]))}, process-dir {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 590, :column 7, :end-line 590, :end-column 18, :arglists (quote ([opts cb data sym]))}, :name replumb.repl/process-dir, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 18, :method-params ([opts cb data sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 590, :end-line 590, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data sym]))}, custom-warning-handler {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 315, :column 7, :end-line 315, :end-column 29, :arglists (quote ([opts cb warning-type env extra])), :doc "Handles the case when the evaluation returns a warning and can be\n  passed as a warning handler when partially applied. At the moment it\n  treats warnings as errors."}, :name replumb.repl/custom-warning-handler, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 29, :method-params ([opts cb warning-type env extra]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 315, :end-line 315, :max-fixed-arity 5, :fn-var true, :arglists (quote ([opts cb warning-type env extra])), :doc "Handles the case when the evaluation returns a warning and can be\n  passed as a warning handler when partially applied. At the moment it\n  treats warnings as errors."}, needs-init-state {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 712, :column 7, :end-line 712, :end-column 23, :arglists (quote ([old-app-env])), :doc "Reset the initialization state, moving to \"Needs Init\", signaling\n  that the we need to initialize the app."}, :name replumb.repl/needs-init-state, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 23, :method-params ([old-app-env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 712, :end-line 712, :max-fixed-arity 1, :fn-var true, :arglists (quote ([old-app-env])), :doc "Reset the initialization state, moving to \"Needs Init\", signaling\n  that the we need to initialize the app."}, repl-read-string {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 60, :column 7, :end-line 60, :end-column 23, :arglists (quote ([line])), :doc "Try to read a string binding all the standard data readers. This\n  function throws if a valid form cannot be found."}, :name replumb.repl/repl-read-string, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 23, :method-params ([line]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 60, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([line])), :doc "Try to read a string binding all the standard data readers. This\n  function throws if a valid form cannot be found."}, make-ns-form {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 171, :column 7, :end-line 171, :end-column 19, :arglists (quote ([kind specs target-ns]))}, :name replumb.repl/make-ns-form, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 19, :method-params ([kind specs target-ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 171, :end-line 171, :max-fixed-arity 3, :fn-var true, :arglists (quote ([kind specs target-ns]))}, persist-init-opts! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 736, :column 7, :end-line 736, :end-column 25, :arglists (quote ([opts])), :doc "Persist the options necessary to the initialization FSM to work."}, :name replumb.repl/persist-init-opts!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 25, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 736, :end-line 736, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :doc "Persist the options necessary to the initialization FSM to work."}, process-in-ns {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 528, :column 7, :end-line 528, :end-column 20, :arglists (quote ([opts cb data ns-string]))}, :name replumb.repl/process-in-ns, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 20, :method-params ([opts cb data ns-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 528, :end-line 528, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data ns-string]))}, reset-last-warning! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 311, :column 7, :end-line 311, :end-column 26, :arglists (quote ([]))}, :name replumb.repl/reset-last-warning!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 26, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 311, :end-line 311, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, process-doc {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 501, :column 7, :end-line 501, :end-column 18, :arglists (quote ([opts cb data sym]))}, :name replumb.repl/process-doc, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 18, :method-params ([opts cb data sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 501, :end-line 501, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data sym]))}, normalize-opts {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 275, :column 7, :end-line 275, :end-column 21, :arglists (quote ([user-opts])), :doc "Process the user options. Returns the map that can be fed to\n  read-eval-call."}, :name replumb.repl/normalize-opts, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 21, :method-params ([user-opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 275, :end-line 275, :max-fixed-arity 1, :fn-var true, :arglists (quote ([user-opts])), :doc "Process the user options. Returns the map that can be fed to\n  read-eval-call."}, call-back! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 387, :column 7, :end-line 387, :end-column 17, :arglists (quote ([opts cb res] [opts cb data res])), :doc "Handles the evaluation result, calling the callback in the right way,\n  based on the success or error of the evaluation. The res parameter\n  expects the same map as ClojureScript's cljs.js callback,\n  :value if success and :error if not. The data parameter might contain\n  additional stuff:\n\n  * :form the source form that has been eval-ed\n  * :on-success-fn! 0-arity function that will be executed on success\n  * :on-error-fn! 0-arity function that will be executed on error\n  * :side-effect-fn! 0-arity function that if present will be executed\n  for both success and error, effectively disabling the individual\n  on-success-fn! and on-error-fn!\n\n  Call-back! supports the following opts:\n\n  * :verbose will enable the the evaluation logging, defaults to false.\n  * :no-pr-str-on-value avoids wrapping successful value in a pr-str\n  * :warning-as-error will consider a warning like an error\n\n  Notes:\n  1. The opts map passed here overrides the environment options.\n  2. This function will also clear the :last-eval-warning flag in\n  app-env.\n  3. It will execute (:side-effect-fn!) or (on-success-fn!)\n  and (on-error-fn!)  *before* the callback is called.\n\n  ** Every function in this namespace should call call-back! as\n  single point of exit. **", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([opts cb res] [opts cb data res]), :arglists ([opts cb res] [opts cb data res]), :arglists-meta (nil nil)}}, :name replumb.repl/call-back!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([opts cb res] [opts cb data res]), :arglists ([opts cb res] [opts cb data res]), :arglists-meta (nil nil)}, :method-params ([opts cb res] [opts cb data res]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 387, :end-line 387, :max-fixed-arity 4, :fn-var true, :arglists ([opts cb res] [opts cb data res]), :doc "Handles the evaluation result, calling the callback in the right way,\n  based on the success or error of the evaluation. The res parameter\n  expects the same map as ClojureScript's cljs.js callback,\n  :value if success and :error if not. The data parameter might contain\n  additional stuff:\n\n  * :form the source form that has been eval-ed\n  * :on-success-fn! 0-arity function that will be executed on success\n  * :on-error-fn! 0-arity function that will be executed on error\n  * :side-effect-fn! 0-arity function that if present will be executed\n  for both success and error, effectively disabling the individual\n  on-success-fn! and on-error-fn!\n\n  Call-back! supports the following opts:\n\n  * :verbose will enable the the evaluation logging, defaults to false.\n  * :no-pr-str-on-value avoids wrapping successful value in a pr-str\n  * :warning-as-error will consider a warning like an error\n\n  Notes:\n  1. The opts map passed here overrides the environment options.\n  2. This function will also clear the :last-eval-warning flag in\n  app-env.\n  3. It will execute (:side-effect-fn!) or (on-success-fn!)\n  and (on-error-fn!)  *before* the callback is called.\n\n  ** Every function in this namespace should call call-back! as\n  single point of exit. **"}, error-map {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 303, :column 7, :end-line 303, :end-column 16, :arglists (quote ([opts form warning error])), :doc "Builds the map to return when the evaluation returned error."}, :name replumb.repl/error-map, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 16, :method-params ([opts form warning error]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 303, :end-line 303, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts form warning error])), :doc "Builds the map to return when the evaluation returned error."}, init-closure-index! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 746, :column 7, :end-line 746, :end-column 26, :arglists (quote ([opts])), :doc "Create and swap in app-env a map from Google Closure provide string\n  to their respective path (without extension).  It merges with the\n  current map if many deps.js are on the source path, precedence to the\n  last (as per merge)."}, :name replumb.repl/init-closure-index!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 26, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 746, :end-line 746, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :doc "Create and swap in app-env a map from Google Closure provide string\n  to their respective path (without extension).  It merges with the\n  current map if many deps.js are on the source path, precedence to the\n  last (as per merge)."}, ns-form? {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 67, :column 7, :end-line 67, :end-column 15, :arglists (quote ([form]))}, :name replumb.repl/ns-form?, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 15, :method-params ([form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 67, :end-line 67, :max-fixed-arity 1, :fn-var true, :arglists (quote ([form]))}, init-repl-if-necessary! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 791, :column 7, :end-line 791, :end-column 30, :arglists (quote ([opts data]))}, :name replumb.repl/init-repl-if-necessary!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 30, :method-params ([opts data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 791, :end-line 791, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts data]))}, initializing-state {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 689, :column 7, :end-line 689, :end-column 25, :arglists (quote ([old-app-env])), :doc "If we are not already :initializing? and :needs-init? is true, then\n  move to the \"Initializing\" state, signaling that the init is in\n  progress."}, :name replumb.repl/initializing-state, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 25, :method-params ([old-app-env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 689, :end-line 689, :max-fixed-arity 1, :fn-var true, :arglists (quote ([old-app-env])), :doc "If we are not already :initializing? and :needs-init? is true, then\n  move to the \"Initializing\" state, signaling that the init is in\n  progress."}, self-require? {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 133, :column 7, :end-line 133, :end-column 20, :arglists (quote ([specs]))}, :name replumb.repl/self-require?, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 20, :method-params ([specs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 133, :end-line 133, :max-fixed-arity 1, :fn-var true, :arglists (quote ([specs]))}, process-pst {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 514, :column 7, :end-line 514, :end-column 18, :arglists (quote ([opts cb data expr]))}, :name replumb.repl/process-pst, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 18, :method-params ([opts cb data expr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 514, :end-line 514, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data expr]))}, init-option-set {:name replumb.repl/init-option-set, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 685, :column 1, :end-line 685, :end-column 21, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 685, :column 6, :end-line 685, :end-column 21}}, add-init-fns {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 266, :column 7, :end-line 266, :end-column 19, :arglists (quote ([opts user-opts])), :doc "Given current and user options, returns a map containing a\n  valid :init-fns,conjoining with the one in current if necessary."}, :name replumb.repl/add-init-fns, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 19, :method-params ([opts user-opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 266, :end-line 266, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts user-opts])), :doc "Given current and user options, returns a map containing a\n  valid :init-fns,conjoining with the one in current if necessary."}, add-default-opts {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 245, :column 7, :end-line 245, :end-column 23, :arglists (quote ([opts user-opts])), :doc "Given user provided options, conjoins the default option map for\n  its :target (string or keyword). Defaults to conjoining :default (browser,\n  aka :js target)."}, :name replumb.repl/add-default-opts, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 23, :method-params ([opts user-opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 245, :end-line 245, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts user-opts])), :doc "Given user provided options, conjoins the default option map for\n  its :target (string or keyword). Defaults to conjoining :default (browser,\n  aka :js target)."}, purge-ns! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 154, :column 7, :end-line 154, :end-column 16, :arglists (quote ([st ns]))}, :name replumb.repl/purge-ns!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 16, :method-params ([st ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 154, :end-line 154, :max-fixed-arity 2, :fn-var true, :arglists (quote ([st ns]))}, reset-init-opts! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 741, :column 7, :end-line 741, :end-column 23, :arglists (quote ([])), :doc "Reset the initialization persisted options."}, :name replumb.repl/reset-init-opts!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 741, :end-line 741, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Reset the initialization persisted options."}, get-var {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 97, :column 7, :end-line 97, :end-column 14, :arglists (quote ([opts env sym]))}, :name replumb.repl/get-var, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 14, :method-params ([opts env sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 97, :end-line 97, :max-fixed-arity 3, :fn-var true, :arglists (quote ([opts env sym]))}, process-load-file {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 646, :column 7, :end-line 646, :end-column 24, :arglists (quote ([{:keys [verbose read-file-fn! src-paths], :as opts} cb data file-name]))}, :name replumb.repl/process-load-file, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 24, :method-params ([p__15038 cb data file-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 646, :end-line 646, :max-fixed-arity 4, :fn-var true, :arglists (quote ([{:keys [verbose read-file-fn! src-paths], :as opts} cb data file-name]))}, map-keys {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 56, :column 7, :end-line 56, :end-column 15, :arglists (quote ([f m]))}, :name replumb.repl/map-keys, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 56, :end-line 56, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m]))}, process-find-doc {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 611, :column 7, :end-line 611, :end-column 23, :arglists (quote ([opts cb data re-string-or-pattern]))}, :name replumb.repl/process-find-doc, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 23, :method-params ([opts cb data re-string-or-pattern]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 611, :end-line 611, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data re-string-or-pattern]))}, process-source {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 574, :column 7, :end-line 574, :end-column 21, :arglists (quote ([opts cb data sym]))}, :name replumb.repl/process-source, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 21, :method-params ([opts cb data sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 574, :end-line 574, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data sym]))}, add-load-fn {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 254, :column 7, :end-line 254, :end-column 18, :arglists (quote ([opts user-opts])), :doc "Given current and user options, if :load-fn! is present in user-opts,\n  conjoins it. Try to create and conjoin one from :src-paths\n  and :read-file-fn! otherwise. Conjoins nil if it cannot."}, :name replumb.repl/add-load-fn, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 18, :method-params ([opts user-opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 254, :end-line 254, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts user-opts])), :doc "Given current and user options, if :load-fn! is present in user-opts,\n  conjoins it. Try to create and conjoin one from :src-paths\n  and :read-file-fn! otherwise. Conjoins nil if it cannot."}, repl-special? {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 107, :column 7, :end-line 107, :end-column 20, :arglists (quote ([form]))}, :name replumb.repl/repl-special?, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 20, :method-params ([form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 107, :end-line 107, :max-fixed-arity 1, :fn-var true, :arglists (quote ([form]))}, last-form {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 635, :column 7, :end-line 635, :end-column 16, :arglists (quote ([source]))}, :name replumb.repl/last-form, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 16, :method-params ([source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 635, :end-line 635, :max-fixed-arity 1, :fn-var true, :arglists (quote ([source]))}, process-require {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 477, :column 7, :end-line 477, :end-column 22, :arglists (quote ([opts cb data kind specs]))}, :name replumb.repl/process-require, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 22, :method-params ([opts cb data kind specs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 477, :end-line 477, :max-fixed-arity 5, :fn-var true, :arglists (quote ([opts cb data kind specs]))}, validated-init-fn! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 342, :column 7, :end-line 342, :end-column 25, :arglists (quote ([init-fn! res]))}, :name replumb.repl/validated-init-fn!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 25, :method-params ([init-fn! res]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 342, :end-line 342, :max-fixed-arity 2, :fn-var true, :arglists (quote ([init-fn! res]))}, goog-deps-map {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 187, :column 7, :end-line 187, :end-column 20, :arglists (quote ([deps-js-content])), :doc "Given the content of goog/deps.js file, create a map\n  provide->path (without extension) of Google dependencies.\n\n  Adapted from planck:\n  https://github.com/mfikes/planck/blob/master/planck-cljs/src/planck/repl.cljs#L438-L451"}, :name replumb.repl/goog-deps-map, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 20, :method-params ([deps-js-content]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 187, :end-line 187, :max-fixed-arity 1, :fn-var true, :arglists (quote ([deps-js-content])), :doc "Given the content of goog/deps.js file, create a map\n  provide->path (without extension) of Google dependencies.\n\n  Adapted from planck:\n  https://github.com/mfikes/planck/blob/master/planck-cljs/src/planck/repl.cljs#L438-L451"}, warning-error-map! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 360, :column 7, :end-line 360, :end-column 25, :arglists (quote ([opts {:keys [error], :as orig}])), :doc "Checks if there has been a warning and if so will return a new result\n  map instead of the input one, potentially with a :warning key\n  containing the warning message in it.\n\n  The code paths are the following:\n\n  - if the input map was already an :error, there will be no warning,\n  the original :error is returned.\n  - if the input map was a :value:\n    - if (:warning-as-error opts) is truey, the new map will always\n      contain it as :error, overriding the original.\n    - if (:warning-as-error opts) is falsey, the new map will contain\n      the warning as :warning along with the original :value"}, :name replumb.repl/warning-error-map!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 25, :method-params ([opts p__14951]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 360, :end-line 360, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts {:keys [error], :as orig}])), :doc "Checks if there has been a warning and if so will return a new result\n  map instead of the input one, potentially with a :warning key\n  containing the warning message in it.\n\n  The code paths are the following:\n\n  - if the input map was already an :error, there will be no warning,\n  the original :error is returned.\n  - if the input map was a :value:\n    - if (:warning-as-error opts) is truey, the new map will always\n      contain it as :error, overriding the original.\n    - if (:warning-as-error opts) is falsey, the new map will contain\n      the warning as :warning along with the original :value"}, load-eval-opts! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 127, :column 7, :end-line 127, :end-column 22, :arglists (quote ([opts file-name]))}, :name replumb.repl/load-eval-opts!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 22, :method-params ([opts file-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 127, :end-line 127, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts file-name]))}, get-goog-path {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 44, :column 7, :end-line 44, :end-column 20, :arglists (quote ([provide])), :doc "Given a Google Closure provide / Clojure require (e.g. goog.string),\n  returns the path to the actual file (without extension)."}, :name replumb.repl/get-goog-path, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 20, :method-params ([provide]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 44, :end-line 44, :max-fixed-arity 1, :fn-var true, :arglists (quote ([provide])), :doc "Given a Google Closure provide / Clojure require (e.g. goog.string),\n  returns the path to the actual file (without extension)."}, init-repl! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 770, :column 7, :end-line 770, :end-column 17, :arglists (quote ([opts data])), :doc "The init-repl function. It uses the following opts keys:\n\n  * :init-fns initialization function vector, it will be executed in\n  order\n\n  Data is passed from outside and will be forwarded to :init-fn!."}, :name replumb.repl/init-repl!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 17, :method-params ([opts data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 770, :end-line 770, :max-fixed-arity 2, :fn-var true, :arglists (quote ([opts data])), :doc "The init-repl function. It uses the following opts keys:\n\n  * :init-fns initialization function vector, it will be executed in\n  order\n\n  Data is passed from outside and will be forwarded to :init-fn!."}, process-1-2-3 {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 437, :column 7, :end-line 437, :end-column 20, :arglists (quote ([data expression-form value]))}, :name replumb.repl/process-1-2-3, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 20, :method-params ([data expression-form value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 437, :end-line 437, :max-fixed-arity 3, :fn-var true, :arglists (quote ([data expression-form value]))}, empty-analyzer-env {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 50, :column 7, :end-line 50, :end-column 25, :arglists (quote ([]))}, :name replumb.repl/empty-analyzer-env, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 25, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 50, :end-line 50, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, extract-namespace {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 77, :column 7, :end-line 77, :end-column 24, :arglists (quote ([source]))}, :name replumb.repl/extract-namespace, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 24, :method-params ([source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 77, :end-line 77, :max-fixed-arity 1, :fn-var true, :arglists (quote ([source]))}, valid-opts-set {:name replumb.repl/valid-opts-set, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 234, :column 1, :end-line 234, :end-column 20, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 234, :column 6, :end-line 234, :end-column 20}, :doc "Set of valid option used for external input validation."}, call-side-effect! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 350, :column 7, :end-line 350, :end-column 24, :arglists (quote ([data {:keys [value error]}])), :doc "Execute the correct side effecting function from data.\n  Handles :side-effect-fn!, :on-error-fn! and on-success-fn!."}, :name replumb.repl/call-side-effect!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 24, :method-params ([data p__14946]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 350, :end-line 350, :max-fixed-arity 2, :fn-var true, :arglists (quote ([data {:keys [value error]}])), :doc "Execute the correct side effecting function from data.\n  Handles :side-effect-fn!, :on-error-fn! and on-success-fn!."}, ex-info-data {:name replumb.repl/ex-info-data, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 37, :column 1, :end-line 37, :end-column 18, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 37, :column 6, :end-line 37, :end-column 18}, :doc "The ex-info data for this file"}, st {:name replumb.repl/st, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 25, :column 1, :end-line 25, :end-column 12, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 25, :column 10, :end-line 25, :end-column 12}}, current-ns {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 39, :column 7, :end-line 39, :end-column 17, :arglists (quote ([])), :doc "Return the current namespace, as a symbol."}, :name replumb.repl/current-ns, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 39, :end-line 39, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Return the current namespace, as a symbol."}, force-init! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 729, :column 7, :end-line 729, :end-column 18, :arglists (quote ([])), :doc "Force the initialization at the next read-eval-call. Use this every\n  time an option that needs to be read at initialization time changes,\n  e.g. :source-path. In the future this will be automated."}, :name replumb.repl/force-init!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 729, :end-line 729, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Force the initialization at the next read-eval-call. Use this every\n  time an option that needs to be read at initialization time changes,\n  e.g. :source-path. In the future this will be automated."}, eval-str* {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 445, :column 7, :end-line 445, :end-column 16, :arglists (quote ([eval-opts user-opts cb data source])), :doc "Custom version of cljs.js/eval-str. The only difference is in the\n  spitting of eval-opts, which is the map which the actual\n  cljs.js/eval-str needs and usually built by base-eval-opts!, and\n  user-opts, passed through read-eval-call (same keys supported).\n\n  Additionally, eval-opts might contain:\n\n  * :file-name In case of file loading, indicates its name\n  * :on-success-fn! 1-arity function that will be executed on success,\n  the input is the evaluation result\n  * :on-error-fn! 1-arity function that will be executed on error, the\n  input is the evaluation result\n  * :side-effect-fn! 1-arity function that if present will be executed\n  for both success and error, effectively disabling the individual\n  on-success-fn! and on-error-fn!. The input is the evaluation result"}, :name replumb.repl/eval-str*, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 16, :method-params ([eval-opts user-opts cb data source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 445, :end-line 445, :max-fixed-arity 5, :fn-var true, :arglists (quote ([eval-opts user-opts cb data source])), :doc "Custom version of cljs.js/eval-str. The only difference is in the\n  spitting of eval-opts, which is the map which the actual\n  cljs.js/eval-str needs and usually built by base-eval-opts!, and\n  user-opts, passed through read-eval-call (same keys supported).\n\n  Additionally, eval-opts might contain:\n\n  * :file-name In case of file loading, indicates its name\n  * :on-success-fn! 1-arity function that will be executed on success,\n  the input is the evaluation result\n  * :on-error-fn! 1-arity function that will be executed on error, the\n  input is the evaluation result\n  * :side-effect-fn! 1-arity function that if present will be executed\n  for both success and error, effectively disabling the individual\n  on-success-fn! and on-error-fn!. The input is the evaluation result"}, app-env {:name replumb.repl/app-env, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 27, :column 1, :end-line 27, :end-column 17, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 27, :column 10, :end-line 27, :end-column 17}}, process-repl-special {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 665, :column 7, :end-line 665, :end-column 27, :arglists (quote ([opts cb data expression-form]))}, :name replumb.repl/process-repl-special, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 27, :method-params ([opts cb data expression-form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 665, :end-line 665, :max-fixed-arity 4, :fn-var true, :arglists (quote ([opts cb data expression-form]))}, resolve {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 83, :column 7, :end-line 83, :end-column 14, :arglists (quote ([opts env sym])), :doc "From cljs.analyzer.api.clj. Given an analysis environment resolve a\n  var. Analogous to clojure.core/resolve"}, :name replumb.repl/resolve, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 14, :method-params ([opts env sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 83, :end-line 83, :max-fixed-arity 3, :fn-var true, :arglists (quote ([opts env sym])), :doc "From cljs.analyzer.api.clj. Given an analysis environment resolve a\n  var. Analogous to clojure.core/resolve"}, macro? {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 71, :column 7, :end-line 71, :end-column 13, :arglists (quote ([var])), :doc "Is the input analyzer var (from either cljs.analyzer/resolve-var or\n  cljs.analyzer/resolve-macro-var) a macro?"}, :name replumb.repl/macro?, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 13, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 71, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var])), :doc "Is the input analyzer var (from either cljs.analyzer/resolve-var or\n  cljs.analyzer/resolve-macro-var) a macro?"}, replumb-repl-special-set {:name replumb.repl/replumb-repl-special-set, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 104, :column 1, :end-line 104, :end-column 30, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 104, :column 6, :end-line 104, :end-column 30}}, process-reloads! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 159, :column 7, :end-line 159, :end-column 23, :arglists (quote ([specs]))}, :name replumb.repl/process-reloads!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 23, :method-params ([specs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 159, :end-line 159, :max-fixed-arity 1, :fn-var true, :arglists (quote ([specs]))}, canonicalize-specs {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 145, :column 7, :end-line 145, :end-column 25, :arglists (quote ([specs]))}, :name replumb.repl/canonicalize-specs, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 25, :method-params ([specs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 145, :end-line 145, :max-fixed-arity 1, :fn-var true, :arglists (quote ([specs]))}, base-eval-opts! {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 111, :column 7, :end-line 111, :end-column 22, :arglists (quote ([] [opts])), :doc "Gets the base set of evaluation options. The 1-arity function\n  specifies opts that override default. No check here if opts are\n  valid.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}}, :name replumb.repl/base-eval-opts!, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}, :method-params ([] [opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 111, :end-line 111, :max-fixed-arity 1, :fn-var true, :arglists ([] [opts]), :doc "Gets the base set of evaluation options. The 1-arity function\n  specifies opts that override default. No check here if opts are\n  valid."}, read-eval-call {:protocol-inline nil, :meta {:file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :line 803, :column 7, :end-line 803, :end-column 21, :arglists (quote ([opts cb source])), :doc "Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * :verbose - will enable the the evaluation logging, defaults to false\n  * :warning-as-error - will consider a compiler warning as error\n  * :target - :nodejs and :browser supported, the latter is used if\n  missing\n  * :init-fn! - user provided initialization function, it will be passed\n  a map of data currently containing:\n\n      :form   ;; the form to evaluate, as data, past the reader step\n      :ns     ;; the current namespace, as symbol\n      :target ;; *target* as keyword, :default is the default\n\n  * :load-fn! - will override replumb's default cljs.js/*load-fn*.\n  It rules out :read-file-fn!, losing any perk of using replumb.load\n  helpers. Use it if you know what you are doing.\n\n  * :read-file-fn! an asynchronous 2-arity function with signature\n  [file-path src-cb] where src-cb is itself a function (fn [source] ...)\n  that needs to be called with the file content as string (nil if no\n  file is found). It is mutually exclusive with :load-fn! and will be\n  ignored in case both are present\n\n  * :src-paths - a vector of paths containing source files\n  * :no-pr-str-on-value - in case of :success? avoid converting the\n  result map :value to string\n\n  The second parameter cb, is a 1-arity function which receives the\n  result map.\n\n  Therefore, given cb (fn [result-map] ...), the main map keys are:\n\n  :success? - a boolean indicating if everything went right\n  :value    - (if (:success? result)), this key contains the yielded value as\n              string, unless :no-pr-str-on-value is true, in which case it\n              returns the bare value.\n  :error    - (if-not (:success? result)) will contain a js/Error\n  :warning  - in case a warning was thrown and :warning-as-error is falsey\n  :form     - the evaluated form as data structure (not a string)\n\n  The third parameter is the source string to be read and evaluated.\n\n  It initializes the repl harness either on first execution or if an\n  option in #{:src-paths :init-fn!} changes from the previous\n  `read-eval-call`."}, :name replumb.repl/read-eval-call, :variadic false, :file "/Users/jared/.boot/cache/tmp/Users/jared/clone/clojure/reepl/1sf7/9xobv7/main.out/replumb/repl.cljs", :end-column 21, :method-params ([opts cb source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 803, :end-line 803, :max-fixed-arity 3, :fn-var true, :arglists (quote ([opts cb source])), :doc "Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * :verbose - will enable the the evaluation logging, defaults to false\n  * :warning-as-error - will consider a compiler warning as error\n  * :target - :nodejs and :browser supported, the latter is used if\n  missing\n  * :init-fn! - user provided initialization function, it will be passed\n  a map of data currently containing:\n\n      :form   ;; the form to evaluate, as data, past the reader step\n      :ns     ;; the current namespace, as symbol\n      :target ;; *target* as keyword, :default is the default\n\n  * :load-fn! - will override replumb's default cljs.js/*load-fn*.\n  It rules out :read-file-fn!, losing any perk of using replumb.load\n  helpers. Use it if you know what you are doing.\n\n  * :read-file-fn! an asynchronous 2-arity function with signature\n  [file-path src-cb] where src-cb is itself a function (fn [source] ...)\n  that needs to be called with the file content as string (nil if no\n  file is found). It is mutually exclusive with :load-fn! and will be\n  ignored in case both are present\n\n  * :src-paths - a vector of paths containing source files\n  * :no-pr-str-on-value - in case of :success? avoid converting the\n  result map :value to string\n\n  The second parameter cb, is a 1-arity function which receives the\n  result map.\n\n  Therefore, given cb (fn [result-map] ...), the main map keys are:\n\n  :success? - a boolean indicating if everything went right\n  :value    - (if (:success? result)), this key contains the yielded value as\n              string, unless :no-pr-str-on-value is true, in which case it\n              returns the bare value.\n  :error    - (if-not (:success? result)) will contain a js/Error\n  :warning  - in case a warning was thrown and :warning-as-error is falsey\n  :form     - the evaluated form as data structure (not a string)\n\n  The third parameter is the source string to be read and evaluated.\n\n  It initializes the repl harness either on first execution or if an\n  option in #{:src-paths :init-fn!} changes from the previous\n  `read-eval-call`."}}, :require-macros {cljs.env.macros cljs.env.macros, cljs cljs.js, cljs.js cljs.js, repl cljs.repl, cljs.repl cljs.repl, cljs.pprint cljs.pprint}, :cljs.analyzer/constants {:seen #{res :load :path :features :read-file-fn! doc import :init-fns = :meta :static-fns :else *2 find :macros :previous-init-opts :default :ns :def-emits-var :name :value :file map? get init-fns :side-effect-fn! find-doc :require :extra :warning-type :nodejs :read-cond *target* :initializing? string? :verbose old-app-env dir *1 > pst :source :env :last-eval-warning in-ns :merge :allow ns :column or :goog-provide->path :warning require nil? :no-pr-str-on-value *e :needs-init? :line :expr instance? not :macro source :current-ns env :opts :kind :file-name :warning-as-error sym :url :replumb.repl/error :source-map :context :reload :error :reload-all :require-macros load-file :form :load-fn! *3 :tag :res :target quote :arglists :import :eof :doc count :success? opts :cljs :on-success-fn! :src-paths :init-fn! :on-error-fn! :forms js/Error and symbol? require-macros apropos cljs.user :data :eval}, :order [:current-ns :last-eval-warning :initializing? :needs-init? :previous-init-opts cljs.user :tag :replumb.repl/error :goog-provide->path :ns :context :expr :read-cond :features :allow :cljs ns :macro map? env symbol? sym :verbose :default :name doc import find-doc dir pst in-ns require source load-file require-macros apropos :source-map :def-emits-var :load :eval :static-fns :load-fn! :file-name :reload :reload-all :import :merge :line :column :macros :path :else :read-file-fn! :no-pr-str-on-value :warning-as-error :target :src-paths :init-fn! :nodejs :init-fns :success? :form :warning :value :error :warning-type :env :extra res find or and get not opts string? nil? instance? js/Error = *target* :side-effect-fn! :on-success-fn! :on-error-fn! :opts :data :res *2 *1 *e *3 quote :kind :require :doc :source :file :meta :forms :arglists :url :eof :require-macros old-app-env > count init-fns]}, :doc nil}